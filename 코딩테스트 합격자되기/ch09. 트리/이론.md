# 트리 개념

### 트리의 특성을 활용하는 분야
- 인공지능: 의사결정나무(Decision Tree) 모델
- 자동 완성 기능
- 데이터베이스
## 나무를 거꾸로 뒤집어 놓은 모양의 트리

![](https://i.namu.wiki/i/8pViDtKiYxEmcz1zj2WHZEpLHeu4q4n1bAjOOTvA4rLde3d-miR4lbCeFRjhzuTV1SLW5vFdg81Q6vb6fm1I9Q.webp)

| 용어    | 설명                                   |
|-------|--------------------------------------|
| 트리    | 계층적인 구조를 가진 자료구조                     |
| 노드    | 트리 자료구조에서 데이터를 저장하는 구성 요소            |
| 간선    | 트리 자료구조에서 노드를 연결하는 구성 요소             |
| 부모 노드 | 어떤 노드의 상위에 연결된 노드                    |
| 자식 노드 | 어떤 노드의 하위에 연결된 노드                    |
| 루트 노드 | 트리의 최상위 노드, 부모 노드가 없는 노드             |
| 리프 노드 | 트리의 최하위 노드, 자식 노드가 없는 노드             |
| 차수    | 어떤 노드가 가지고 있는 자식 노드의 수               |
| 레벨    | 루트 노드에서 시작해 특정노트에 이르기까지 거치게 되는 간선의 수 |
| 서브트리  | 트리에 포함되어 있는 부분 트리      

# 이진 트리 표현하기

## 배열로 표현하기
![](https://scarletbreeze.github.io/assets/posts/20190721/2.png)

- 루트 노드는 배열 인덱스 1번에 저장
- 왼쪽 자식 노드의 배열 인덱스는, 부모 노드의 배열 인덱스 × 2
- 오른쪽 자식 노드의 배열 인덱스는, 부모 노드의 배열 인덱스 × 2 + 1
- 부모 노드의 배열 인덱스는, 자식 노드의 배열 인덱스 ÷ 2 (소수점 버림)

- 비교적 구현 난이도가 쉬워, 메모리만 충분하다면 간단한 이진 트리를 구현할 때 유용

## 포인터로 표현하기
![](https://blog.kakaocdn.net/dna/bIOjOC/btrDoaLxjsa/AAAAAAAAAAAAAAAAAAAAAIJUy3lxjRqhjxzHwXU3eFrhyjeZcCCAvMmMFVEKVzZw/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=uhedDBBYeMu1bTspDXB6xvOWxi4%3D)

- 왼쪽 자식 노드(포인터) / 값 / 오른쪽 자식 노드(포인터)
- 각 노드가 자신의 자식 노드를 가리키는 포인터를 가지고 있음
- 메모리를 효율적으로 사용할 수 있어, 노드의 개수가 자주 변하는 이진 트리를 구현할 때 유용
- 포인터를 사용하기 때문에 구현 난이도가 다소 높음

## 이진 트리 순회하기
- 트리의 모든 노드를 방문하는 작업
- 부모의 위치를 어디에 시작하는지에 따라, 전위 순회(Preorder Traversal), 중위 순회(Inorder Traversal), 후위 순회(Postorder Traversal)로 나뉨

### 전위 순회 과정 살펴보기
- 노드를 먼저 방문한 후, 왼쪽 서브트리와 오른쪽 서브트리를 순회하는 방법
- 노드(부모) -> 왼쪽 자식 -> 오른쪽 자식

![](https://upload.wikimedia.org/wikipedia/commons/a/ac/Preorder-traversal.gif)

### 중위 순회 과정 살펴보기
- 왼쪽 서브트리를 먼저 순회한 후, 노드를 방문하고, 마지막으로 오른쪽 서브트리를 순회하는 방법
- 왼쪽 자식 -> 노드(부모) -> 오른쪽 자식

![](https://upload.wikimedia.org/wikipedia/commons/4/48/Inorder-traversal.gif)

### 후위 순회 과정 살펴보기
- 왼쪽 서브트리와 오른쪽 서브트리를 먼저 순회한 후, 노드를 방문하는 방법
- 왼쪽 자식 -> 오른쪽 자식 -> 노드(부모)

![](https://upload.wikimedia.org/wikipedia/commons/2/28/Postorder-traversal.gif)

# 이진 트리 탐색하기

## 이진 탐색 트리 구축하기

![](https://upload.wikimedia.org/wikipedia/commons/9/9c/Optimal-binary-search-tree-from-sorted-array.gif?20200610182412)

- 이진 탐색 트리는 현재 노드보다 값이 작으면 왼쪽 자식 노드로, 값이 크면 오른쪽 자식 노드로 배치하는 규칙이 있음

## 이진 탐색 트리 탐색하기

![](https://blog.penjee.com/wp-content/uploads/2015/11/binary-search-tree-sorted-array-animation.gif)
1. 찾으려는 값이 현재 노드 값과 같으면 탐색을 종료하고 크면 오른쪽 노드를 탐색
2. 본인이 찾으려는 값이 현재 노드 값보다 작으면 왼쪽 노드를 탐색
3. 값을 찾으면 종료. 노드가 없을 때까지 계속 탐색했는데 값이 없으면 트리에 값이 없는 것임.

### 배열 탐색과 비교

- 배열은 배열의 크기만큼 비교 연산이 필요하지만, 이진 탐색 트리는 트리의 높이만큼 비교 연산이 필요
- 이는 데이터 크기에 따라 하위 데이터 중 한 방향을 검색 대상에서 제외하는 특성을 가지고 있기 때문

### 이진 탐색 트리의 시간 복잡도

- 균형이 맞는 경우: O(log n)
- 균형이 맞지 않는 경우: 배열과 비슷할 수 있음
- Like this: ![](https://csnote.net/assets/img/ds/skewed_tree.png)

# 참고자료
- https://namu.wiki/w/%ED%8A%B8%EB%A6%AC%28%EA%B7%B8%EB%9E%98%ED%94%84%29
- https://scarletbreeze.github.io/articles/2019-07/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%2820-23%29
- https://myvelop.tistory.com/152
- https://en.wikipedia.org/wiki/Tree_traversal
- https://commons.wikimedia.org/wiki/File:Optimal-binary-search-tree-from-sorted-array.gif
- https://ejklike.github.io/2018/01/09/traversing-a-binary-tree-1.html
- https://csnote.net/