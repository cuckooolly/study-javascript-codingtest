# 그래프의 개념

## 그래프 용어 정리
- 노드: 그래프의 구성 요소, 정점(vertex)라고도 함
- 간선: 노드와 노드를 연결하는 선, 엣지(edge)라고도 함
- 가중치: 간선에 부여된 값, 비용(cost)이라고도 함

## 그래프의 특징과 종류

### 흐름을 표현하는 방향성
- 방향 그래프: 간선에 방향이 있는 그래프
- 무방향 그래프: 간선에 방향이 없는 그래프

### 흐름의 정도를 표현하는 가중치
- 가중치 그래프: 간선에 가중치가 부여된 그래프

### 시작과 끝의 연결 여부를 보는 순환
- 순환 그래프: 순환이 존재하는 그래프
- 비순환 그래프: 순환이 존재하지 않는 그래프

### 그래프 구현
- 기본적인 그래프의 구성요소
  - 노드, 간선, 방향, 가중치

#### 인접 행렬 그래프 표현
- 2차원 배열을 이용하여 구현
- 배열의 인덱스는 노드를, 배열의 값은 간선을 의미
  - 인덱스의 세로 방향을 출발 노드, 인덱스의 가로 방향을 도착 노드로 생각

#### 인접 리스트 그래프 표현
- 인접 리스트용 노드 구성: 정점 / 가중치 / 다음 노드
- 인접 리스트 그래프 표현 방식
  - 노드 개수 만큼의 배열을 준비
  - 배열의 인덱스는 각 시작 노드를 의미, 배열의 값에는 다음 노드를 연결

#### 인접 행렬과 인접 리스트의 장/단점
- 인접 행렬
  - 장점
    - 간선 정보를 확인할 때의 시간복잡도가 O(1)로 빠름
    - 구현 난이도가 낮음
  - 단점
    - 인접 행렬로 희소 그래프를 표현하게 되는 경우, 대부분은 사용하지 않게 되어 비효율적
    - 노드들의 값이 차이가 매우 큰 그래프를 표현하는 경우, 가장 큰 노드 값을 기준으로 행렬의 크기를 잡아야 하므로 비효율적임
- 인접 리스트
  - 장점
    - 인접 행렬에 비해 메모리 사용이 효율적: 사용하는 노드(공간)만 정의해서 사용하기 때문
  - 단점
    - 간선 정보를 확인할 때의 시간복잡도가 O(N)으로 느림
    - 구현이 (인접 행렬에 비해서) 다소 복잡함

# 그래프 탐색

## 그래프 탐색 알고리즘의 종류
- 깊이 우선 탐색: 더 이상 탐색할 노드가 없을 까지 가본 뒤, 더 이상 탐색할 노드가 없으면 최근에 방문했던 노드로 되돌아간 다음, 가지 않은 노드를 방문
- 너비 우선 탐색: 현재 위치에서 가장 가까운 노드부터 모두 방문하고 다음 노드로 넘어감, 그 노드에서 가장 가까운 노드부터 모두 방문

## 깊이 우선 탐색
### 깊이 우선 탐색의 탐색 방향
![](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)

### 배열과 스택을 이용한 구현
![](https://static-assets.codecademy.com/Courses/CS102-Data-Structures-And-Algorithms/Breadth-First-Search-And-Depth-First-Search/Depth-First-Tree-Traversal.gif)

### 코드로 구현하기
- 스택이 비었는지 확인하기. 스택이 비었다는 것은 방문할 수 있는 모든 노드를 방문했음을 의미하므로, 탐색을 종료
- 스택에서 노드를 꺼냄.
- 꺼낸 노드의 방문 여부를 확인. 이미 방문한 노드라면 별도의 처리가 없음. 아직 방문하지 않았다면 노드를 방문 처리
- 방문한 노드와 인접한 노드를 확인. 그 중에서 방문하지 않은 노드를 스택에 넣음. 스택은 LIFO 구조이므로 역순으로 넣어줘야 함.

### 백트래킹 구현하기
- 백트래킹: 탐색하고 있는 방향의 역방향으로 되돌아가는 동작
- 스택으로 구현하기: 교재 참고
- 스택+재귀함수로 구현하기: 교재 참고

### 코드로 구현할 때 고려사항
- 탐색할 노드가 없을 때까지 간선을 타고 내려갈 수 있어야 함
- 가장 최근에 방문한 노드를 알아야 함
- 이미 방문한 노드인지 확인할 수 있어야 함

## 너비 우선 탐색
### 너비 우선 탐색의 탐색 방향
![](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)

### 배열과 큐를 이용한 구현
![](https://lh5.googleusercontent.com/JKY4V8OZEs5L68Mh2ZY5ZqiqGkaj8esWnTEUwEdygFQdRFowh7aCWpibaPRqkcR3SHBh2Q4Io856f2fAzM5Ae3nD2uLj7AEU3NnQfZ55E2ni0EzXceoVTJtHzqGlUhQ9-izy5Y0v1DK0xIQ4vUxs9Ds)

### 코드로 구현하기
- 큐가 비었는지 확인. 큐가 비었다는 것은 방문할 수 있는 모든 노드를 방문했음을 의미하므로, 탐색을 종료
- 큐에서 노드를 꺼냄
- 꺼낸 노드의 방문 여부를 확인. 이미 방문한 노드라면 별도의 처리가 없음. 아직 방문하지 않았다면 노드를 방문 처리

### 코드로 구현할 때 고려사항
- 현재 방문한 노드와 직접 연결된 모든 노드를 방문할 수 있어야 함
- 이미 방문한 노드인지 확인할 수 있어야 함

## 깊이 우선 탐색과 너비 우선 탐색의 비교
- 깊이 우선 탐색: 깊게 탐색 후 되돌아 오는 특성이 있음 / 최단 경로를 찾는게 아니라면, 깊이 우선 탐색을 우선 고려해보자.
- 너비 우선 탐색: 시작 노드에서 인접한 노드부터 방문하는 특성이 있음

# 그래프 최단 경로 구하기
## 다익스트라 알고리즘
- 알고리즘 구현
1. 시작 노드를 설정하고, 시작 노드로부터 특정 노드까지의 최소 비용을 저장할 공간과 직전 노드를 저장할 공간을 마련
   1. 최소 비용을 저장할 공간은 매우 큰 값으로 초기화, 직전 노드를 저장할 공간도 매우 큰 값으로 초기화.
   2. 시작 노드의 최소 비용은 0, 직전 노드는 자기 자신.
2. 해당 노드를 통해 방문할 수 있는 노드 중, 현재까지 구한 최소 비용이 가장 적은 노드를 선택
   1. 해당 노드를 거쳐서 각 노드까지 가는 최소 비용과 현재까지 구현 최소 비용을 비교하여 작은 값을 각 노드의 최소 비용으로 갱신
   2. 직전 노드도 같이 갱신
3. 노드 개수에서 1을 뺀 만큼 반복
- 알고리즘 작동
![](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*qG4-VA4dmMNHu9Kafat30g.gif)

## 벨만-포드 알고리즘
- 알고리즘 구현
1. 시작노드를 설정한 다음, 시작 노드의 최소 비용은 0, 나머지 노드는 최대 값으로 초기화. 이후 최소 비용을 갱신할 때 직전 노드도 갱신
2. 노드 개수 -1만큼 다음 연산을 반복
   1. 시작 노드에서 갈 수 있는 각 노드에 대해, 각 노드를 거쳐갈 때 현재까지 구한 최소 비용보다 더 적은 최소 비용이 있는지 확인하여 갱신. 갱신할 때, 직전 노드 값도 같이 갱신
3. 2-1을 마지막으로 한번 더 수행하여, 갱신되는 최소 비용이 있는지 확인. 만약 있다면 음의 순환이 있음을 의미함
- 알고리즘 작동
![](https://upload.wikimedia.org/wikipedia/commons/7/77/Bellman%E2%80%93Ford_algorithm_example.gif?20220707105220)

## 정리
|            | 목적                          | 장단점 및 특징                                                    | 시간복잡도                           |
|------------|-----------------------------|-------------------------------------------------------------|---------------------------------|
| 다익스트라 알고리즘 | 출발 노드로부터 도착 노드들까지의 최단 경로 찾기 | 음의 가중치를 가지는 그래프에서 최단 경로를 구할 수 없음 (그리디 방식)                   | O(V^2), 우선 순위 큐로 계산하면 O(E*logV) |
| 벨만-포드 알고리즘 | 출발 노드로부터 도착 노드들까지의 최단 경로 찾기 | 음의 가중치를 가지는 그래프에서도 최단 경로를 구할 수 있음 (동적 계획법). 음의 순환도 감지할 수 있음 | O(V*E)                          |

# 참고자료
- https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%BC:Depth-First-Search.gif
- https://www.codecademy.com/article/depth-first-search-dfs-algorithm
- https://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif
- https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/
- https://python.plainenglish.io/how-does-the-dijkstras-algorithm-work-dc59da031f3f
- https://commons.wikimedia.org/wiki/File:Bellman%E2%80%93Ford_algorithm_example.gif
- https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html