# 정렬 개념
- 정렬: 사용자가 정의한 순서대로 데이터를 나열하는 것

## 정렬이 필요한 이유
- 원하는 데이터를 쉽게 찾기 위함
  - 데이터를 정렬하여, 중앙 값을 빠르게 찾을 수 있음

## 삽입 정렬
 - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
### 구체적인 알고리즘
   1. 최초에는 정렬된 영역은 왼쪽 1개, 정렬되지 않은 영역을 나머지로 정함
   2. 키(정렬되지 않은 영역의 가장 맨 앞에 있는 값)와 정렬된 영역의 맨 끝 값부터 거슬러 올라가며 다음 처리를 수행
      1. 키보다 크면 해당 값을 오른쪽으로 한 칸 밀어 냄
      2. 키보다 작거나 더 이상 비교할 값이 없으면 밀어낸 자리에 키를 넣음
   3. 모든 데이터가 정렬될 때까지 2번 과정을 반복<br>
![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Insertion_sort_001.PNG)
### 복잡도
 - 시간 복잡도: O(n^2)

## 병합 정렬
 - 정렬되지 않은 영역을 쪼개서, 각 영역을 정렬하고 합치며 정렬하는 알고리즘
### 간단한 알고리즘
   - 정렬되지 않은 영역을 반으로 쪼갬
   - 쪼갠 영역이 1개가 될 때까지 재귀적으로 반복
   - 쪼갠 영역을 합치며 정렬 
### 구체적인 알고리즘
   - 각 데이터의 첫번째 원소를 가리키는 포인터를 만듦
     - 포인터가 가리키는 두 값 중 작은 값을 선택해 새 저장 공간에 저장
     - 값이 선택된 포인터는 다음 위치의 값을 가리킴
   - 새 저장 공간에 하나의 데이터가 완전히 저장될 때까지 1.번을 반복
     - 저장할 값이 남은 데이터의 값을 순서대로 새로운 저장 공간에 저장
     - 새로운 저장 공간에 2개의 데이터가 정렬된 상태로 저장
   - 새로운 저장소에 저장된 값의 개수와 초기에 주어진 데이터에 들어있는 값의 개수가 같을 때까지 1,2를 반복<br>
![](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)
### 복잡도
 - 시간 복잡도: O(n log n) / 공간 복잡도: O(n)

## 힙 정렬
- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
  - 내림차순 정렬: 최소 힙 트리(부모 노드가 자식 노드 보다 작음)
  - 오름차순 정렬: 최대 힙 트리(부모 노드가 자식 노드 보다 큼)
### 구체적인 알고리즘
  - 힙 구축 방법: 최대 힙
    1. 현재 노드와 자식 노드의 값을 비교
       1. 현재 노드의 값이 가장 크지 않으면, 자식 노드 중 가장 큰 값과 현재 노드의 값을 바꿈
       2. 자식 노드가 없거나 현재 노드의 값이 가장 크면 연산을 종료
    2. 맞바꾼 자식 노드의 위치를 현재 노드로 하여 과정 1을 반복
  - 힙 정렬 과정: 최대 힙
    1. 정렬하지 않은 데이터로 힙을 구축
    2. 현재 최대힙의 루트 노드와 마지막 노드를 맞바꿈. 맞바꾼 뒤 마지막 노드는 최대힙에서 제외.
    3. 최대힙은 마지막 노드가 루트 노드가 되었음. 최대 힙을 재 구축하고 과정 2를 수행. 이는 최대힙의 크기가 1이 될 때까지 반복
### 복잡도
- 시간 복잡도: O(n log n) / 공간 복잡도: O(1)<br>

## 우선순위 큐
- 우선순위가 높은 데이터부터 먼저 처리하는 큐
### 우선순위 큐가 동작하는 방식
  1. 빈 우선순위 큐를 하나 선언
  2. 숫자들을 삽입
  3. 우선순위가 높은 순서대로 POP을 진행
### 우선순위 큐가 활용되는 분야
  - 작업 스케줄링
  - 응급실 대기열
  - 네트워크 트래픽 제어
  - 교통 네트워크 최적화 등

## 위상 정렬
- 일의 순서가 있는 작업을 순서에 맞춰 정렬하는 알고리즘
### 위상 정렬과 진입 차수<br>
![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Directed_acyclic_graph_2.svg/458px-Directed_acyclic_graph_2.svg.png)
- 진입차수: 자신을 향한 화살표의 갯수
- 진입차수가 0이면, 선행 작업이 필요 없는 일이라고 할 수 있음
### 위상 정렬 과정
- 진입차수가 0인 노드를 큐에 넣는다.
- 해당 노드의 자식 노드들의 진입차수를 1 줄인다.
- 그래프의 모든 노드가 큐에 넣어질 때까지 1 - 2번을 반복한다.
- 큐에서 하나씩 꺼내면 위상 정렬된 노드들을 얻을 수 있다<br>
![](https://i.imgur.com/DWda0g7.gif)
### 복잡도
- 시간 복잡도: O(|V| + |E|) / 공간 복잡도: O(|V|)

## 계수 정렬
- 데이터의 크기 범위가 제한되어 있을 때, 각 데이터가 몇 번 나왔는지 세어서 정렬하는 알고리즘
### 구체적인 알고리즘
  1. 입력 데이터의 최댓값과 최솟값을 찾음
  2. 최댓값과 최솟값의 차이만큼 크기를 갖는 배열을 만듦
  3. 입력 데이터의 각 값에 해당하는 인덱스의 값을 1씩 증가시킴
  4. 배열을 순회하며, 인덱스의 값이 0이 아닐 때 해당 인덱스를 결과 배열에 인덱스의 값만큼 추가함<br>
### 복잡도
- 시간 복잡도: O(n + k) / 공간 복잡도: O(k)
  - n: 입력 데이터의 개수 / k: 데이터의 최대값 ~ 최소값

# 참고자료
- https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC
- https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC
- https://ko.wikipedia.org/wiki/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC
- https://haedallog.tistory.com/122
- https://ko.wikipedia.org/wiki/%EA%B3%84%EC%88%98_%EC%A0%95%EB%A0%AC

