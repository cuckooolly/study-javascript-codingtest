/*
문제: 2 x n 타일링
가로 길이가 2이고 세로 길이가 1인 직사각형 모양의 타일이 있습니다.
이 타일을 이용하여 세로 길이가 2이고 가로 길이가 n인 바닥을 가득 채우려고 합니다.
타일을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.

제한 사항:
- 가로의 길이 n은 60,000 이하의 자연수입니다.
- 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.

입출력 예:
n = 4  → result = 5
설명: 2x4 바닥을 채우는 방법은 다음과 같이 5가지입니다.
- ||| (세로 타일 4개)
- ||= (세로 2개 + 가로 2개)
- |=| (세로 + 가로 2개 + 세로)
- =|| (가로 2개 + 세로 2개)
- == (가로 2개씩 2번)

해결 방법: 동적 계획법 (Dynamic Programming) + 메모이제이션 (Memoization)
- 점화식: dp[n] = dp[n-1] + dp[n-2]
  * 마지막에 세로 타일 1개를 놓는 경우: dp[n-1]가지
  * 마지막에 가로 타일 2개를 놓는 경우: dp[n-2]가지
- 피보나치 수열과 동일한 패턴
*/

function solution(n) {
    // 기저 사례(Base Case): 가로 길이가 1 또는 2인 경우
    // n=1: 세로 타일 1개만 놓는 방법 1가지
    if (n === 1) return 1;

    // n=2: 세로 타일 2개 또는 가로 타일 2개를 놓는 방법 2가지
    if (n === 2) return 2;

    // 메모이제이션을 위한 DP 배열 생성
    // dp[i]는 가로 길이가 i일 때 타일을 채우는 방법의 수를 저장
    const dp = Array(n + 1).fill(0);

    // 초기값 설정 (기저 사례를 배열에 저장)
    dp[1] = 1; // 가로 길이 1: 1가지
    dp[2] = 2; // 가로 길이 2: 2가지

    // Bottom-Up 방식으로 3부터 n까지 계산
    for (let i = 3; i <= n; i++) {
        // 점화식: dp[i] = dp[i-1] + dp[i-2]
        // dp[i-1]: 마지막에 세로 타일(1x2) 1개를 추가하는 경우
        // dp[i-2]: 마지막에 가로 타일(2x1) 2개를 추가하는 경우
        // 큰 수의 오버플로우 방지를 위해 1,000,000,007로 나눈 나머지 저장
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
    }

    // n번째 타일링 방법의 수 반환
    // 메모이제이션된 값을 바로 반환 (O(1) 시간 복잡도)
    return dp[n];
}

// 시간 복잡도: O(n) - n번 반복
// 공간 복잡도: O(n) - n+1개의 값을 배열에 저장

// 테스트
console.log(solution(4)); // 5
