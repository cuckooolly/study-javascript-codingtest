# 동적 계획법 개념

- 작은 부분 문제를 나눠서, 전체 큰 문제를 해결하는 방식
- 동적 계획법의 조건
  - 큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복해서 등장 -> 최적 부분 구조
  - 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성할 수 있어야 함 -> 중복 부분 문제

## 점화식 세우기와 동적 계획법

- 동적 계획법으로 문제를 해결하는 절차
  1. 문제를 해결하는 해가 이미 있다고 가정
  2. 종료 조건을 설정
  3. 1,2 과정을 점화식으로 표현
- 예시: Factorial 문제
  1. Fact(N)이라는 팩토리얼 값을 반환하는 함수가 있다고 가정
  2. Fact(N)의 종료 조건을 알아냄
  3. 종료 조건을 기반으로, 점화식을 세움 
    - Fact(N) = Fact(N-1) * N (N>1)
    - Fact(1) = 1 (N=1)

### 점화식 구현: 재귀 활용
```javascript
Fact(N) {
    if(N이 1이면) 1 반환 // 종료 조건
    else Fact(N-1) * N 반환 // 일반항
}
```

- 재귀함수 호출에 문제가 생겼을 때, 해결하는 방법
  - 반복문: 재귀 호출 자체를 쓰지 않는 법
  - 메모이제이션: 재귀 호출의 횟수를 줄이는 법

## 재귀 호출 횟수를 줄여주는 메모이제이션
- 메모이제이션: 이미 계산한 값을 저장해두었다가, 쓸 일이 있을 때 활용하는 개념
- 예시
  - Fact(1) ~ Fact(5)까지의 값을 저장해두었다가, Fact(6)을 빠르게 계산

### 점화식 구현: 재귀 + 메모이제이션 활용
- 연산 과정
  1. 메모이제이션을 위한 저장소 생성: 이미 구한 해를 저장할 공간을 생성
  2. 재귀 함수 정의: 점화식을 재귀로 표현할 함수를 정의. 함수의 세부 구현은 고려하지 않음
  3. 재귀 함수 종료 조건 정의: 종료 값을 메모이제이션 저장소에 저장하고 종료 조건으로 생각
  4. 재귀 함수의 일반 연산 처리: 동적 계획법에서는 점화식으로 나머지 문제를 처리, 결과 값은 메모이제이션 저장소에 저장

- 예시 코드
```javascript
fiboData[1...N] // 메모이제이션을 위한 배열 선언

fibo(N){
    if(fiboData[N] != 0) return fiboData[N] // 메모이제이션 활용
    if(N이 2 이하이면) fiboData[N]에 1 삽입 // 메모이제이션, 종료 조건
    else fiboData[N]에 fibo(N-1) + fibo(N-2) // 메모이제이션, 일반항 
}

return fiboData[N]
```

- 지금까지 문제를 해결한 방법
  - 점화식 작성(가정한다)
  - 재귀 방식으로 풀어보기(반복한다)
  - 동적 계획법으로 재귀+메모이제이션으로 구현(기억한다)

## 최장 증가 부분 수열
### 부분 수열이란?
- 수열 중 일부를 뽑아 새로 만든 수열을 의미
- 각각의 원소는 전후 관계를 유지해야 함
### 최장 부분 증가 수열이란?
- 오름차순을 유지하면서도 길이가 가장 긴 수열
### LIS의 길이를 동적 계획법으로 구하기
- LIS의 특징
  - 숫자가 점점 증가함
  - 원소 간의 전후 관계는 유지함
- 특정 숫자로 끝나는 LIS의 길이를 구하는 방법: LIS 길이 중 가장 큰 것에 1을 더함
  - dp[i]: i번째 원소로 끝나는 LIS의 길이
  - dp[i] = max(dp[j]) + 1 (0 <= j < i, arr[j] < arr[i])
  - 초기값: dp[i] = 1 (모든 i에 대해)
- 전체 LIS 길이 구하기: dp 배열에서 가장 큰 값
### LIS 길이 알고리즘 분석
- 총 연산 횟수는 dp를 채우는 것과 같으므로, O(N^2)
## 최장 공통 부분 수열
- 두 수열이 어떤 기준에 따라 양쪽에서 공통으로 발견할 수 있는 가장 긴 부분 수열
### LCS 길이 찾는 방법?
- 두 문자열 X[1..m], Y[1..n]에 대해 DP 테이블을 만듭니다:
  - dp[i][j] = X[1..i]와 Y[1..j]의 LCS 길이

### LCS의 길이 점화식 생각하기
- 두 문자의 마지막 글자가 같을 때:
  - dp[i][j] = dp[i-1][j-1] + 1
- 두 문자의 마지막 글자가 다를 때:
  - dp[i][j] = max(dp[i-1][j], dp[i][j-1])
- 초기값 설정:
  - dp[0][j] = 0 (j=0..n)
  - dp[i][0] = 0 (i=0..m)

??? 더 공부해보겠습니다. ???

### LCS 길이 알고리즘 분석
- 총 연산 횟수는 dp를 채우는 것과 같으므로, O(N*M)