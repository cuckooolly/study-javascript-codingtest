/*
문제: 정수 삼각형
삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾으려고 합니다.
아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다.

예시:
    7
   3 8
  8 1 0
 2 7 4 4
4 5 2 6 5

위 삼각형의 경우 7 → 3 → 8 → 7 → 5 의 경로를 거쳐 최대값 30을 얻을 수 있습니다.

제한 사항:
- 삼각형의 높이는 1 이상 500 이하입니다.
- 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.

입출력 예:
triangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]  → result = 30

해결 방법: 동적 계획법 (Dynamic Programming) - Bottom-Up 방식
- 삼각형의 맨 아래부터 위로 올라가면서 각 위치에서의 최대 경로 합을 계산
- dp[i][j]: i번째 행의 j번째 원소에서 시작하여 맨 아래까지 갈 수 있는 최대 경로 합
- 점화식: dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]
*/

function solution(triangle) {
    // 삼각형의 높이(행의 개수)를 저장
    const n = triangle.length;

    // 메모이제이션을 위한 2차원 DP 배열 생성
    // dp[i][j]: i번째 행의 j번째 원소에서 시작하여 맨 아래까지의 최대 경로 합을 저장
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    // 기저 사례: 맨 아래 행(마지막 행)의 값들로 DP 배열 초기화
    // 마지막 행에서는 더 이상 아래로 갈 수 없으므로 자기 자신의 값이 최대값
    for (let i = 0; i < n; i++) {
        dp[n-1][i] = triangle[n-1][i];
    }

    // Bottom-Up 방식: 아래에서 위로 올라가면서 최대 경로 합 계산
    // i는 아래에서 두 번째 행(n-2)부터 맨 위(0)까지 역순으로 순회
    for (let i = n - 2; i >= 0; i--) {
        // j는 현재 행의 첫 번째 원소(0)부터 마지막 원소(i)까지 순회
        // i번째 행에는 i+1개의 원소가 있음
        for (let j = 0; j <= i; j++) {
            // 점화식 적용: 현재 위치에서 아래로 갈 수 있는 두 경로 중 최댓값 선택
            // dp[i+1][j]: 대각선 왼쪽 아래로 가는 경로의 최대값
            // dp[i+1][j+1]: 대각선 오른쪽 아래로 가는 경로의 최대값
            // 두 경로 중 더 큰 값을 선택하고 현재 위치의 값(triangle[i][j])을 더함
            dp[i][j] = Math.max(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j];
        }
    }

    // 꼭대기(0번째 행, 0번째 원소)에서 시작하는 최대 경로 합 반환
    // Bottom-Up으로 계산했으므로 dp[0][0]에 전체 삼각형의 최대 경로 합이 저장됨
    return dp[0][0];
}

// 시간 복잡도: O(n²) - 삼각형의 모든 원소를 한 번씩 순회 (1+2+3+...+n = n(n+1)/2)
// 공간 복잡도: O(n²) - n x n 크기의 2차원 DP 배열 사용

// 테스트
console.log(solution([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]])); // 30
