# 그리디 개념
- 그리디 알고리즘: 문제 해결 과정에서 눈 앞에 보이는 최선의 선택을 하며 선택은 번복하지 않는 것을 의미

## 그리디 알고리즘으로 거스름돈 내어주기
- 손님에게 8원을 거슬러 줘야 하는데, 동전 종류가 5,4,1원짜리 동전이 있다고 가정
- 그리디 알고리즘 적용
    1. 가장 큰 단위의 동전부터 거슬러 줄 수 있는 만큼 거슬러 준다
    2. 남은 금액에 대해 1번 과정을 반복한다
- 8원을 거슬러 주는 과정
    - 5원짜리 동전 1개 거슬러 줌 -> 남은 금액 3원
    - 4원짜리 동전은 거슬러 줄 수 없음 -> 남은 금액 3원
    - 1원짜리 동전 3개 거슬러 줌 -> 남은 금액 0원
- 총 거슬러 준 동전: 5원짜리 1개, 1원짜리 3개 -> 총 4개
- 이 방법이 최적의 해인지 확인하기 위해 다른 방법을 고려
    - 4원짜리 동전 2개 거슬러 주기 -> 남은 금액 0원
    - 총 거슬러 준 동전: 4원짜리 2개 -> 총 2개
- 그리디 알고리즘이 항상 최적의 해를 보장하지 않음을 확인

## 그리디 알고리즘이 최적해를 보장하려면?
1. 최적 부분 구조: 부분해를 푸는 과정이 최적해를 구하는 과정과 일치
2. 그리디 선택 속성: 선택 과정이 다른 과정에 영향을 주지 않음

- 그리디 알고리즘은 최적 부분 구조도 아니고, 그리디 선택 속성도 만족하지 않음
- 따라서 그리디 알고리즘이 항상 최적해를 보장하지 않음
- 하지만, 문제의 특성과 알고리즘 선택 기준을 잘 이해하면 유용하게 활용할 수 있음

# 최소 신장 트리
- 그리디 알고리즘을 활용하는 대표적인 트리형태의 자료구조
## 신장 트리란?
- 신장 트리: 모든 정점이 간선으로 연결되어 있고, 간선 갯수가 정점 갯수보다 하나 적은 그래프

![](https://velog.velcdn.com/images/elon/post/45775759-ed7c-4afd-a8bd-f10efcf1a021/image.png)

## 최소 신장 트리란?
- 최소 신장 트리: 신장 트리 중에서 간선의 가중치 합이 최소인 트리

### 최소 신장 트리 구하는 그리디 알고리즘: 크루스칼 알고리즘
- 구하는 방법: 최소 가중치를 가지는 간선부터 하나씩 추가하는 방식
  1. 그래프의 모든 간선을 가중치 기준으로 오름차순 정렬
  2. 가중치가 낮은 간선부터 최소 신장 트리에 하나씩 추가합니다. (이 부분이 그리디적 선택) / 단, 사이클을 형성하지 않아야 합니다.
  3. 과정 2를 신장 트리 조건에 만족할 때까지 반복합니다.

![](https://velog.velcdn.com/images/elon/post/9595247d-8411-4d3c-93e7-5fb3ea9d91f8/image.png)

### 최소 신장 트리 구하는 그리디 알고리즘: 프림 알고리즘
- 구하는 방법: 임의 정점에서 최소 인접 가중치를 가지는 정점을 찾아 확장하는 방식
  1. 임의의 정점을 하나 선택해서 최소 신장 트리에 추가합니다.
  2. 최소 신장 트리와 연결되어 있는 정점 중, 가장 가중치가 적은 정점을 최소 신장 트리에 추가합니다. (이 부분이 그리디적 선택) / 단, 사이클을 형성하지 않아야 합니다.
  3. 과정 2를 신장 트리 조건에 만족할 때까지 반복합니다.

![](https://velog.velcdn.com/images/elon/post/03895da8-6f1f-4c2d-a9e5-540e288de597/image.png)

|         | 프림                                    | 크루스칼                         |
|---------|---------------------------------------|------------------------------|
| 알고리즘 목적 | 최소 신장 트리                              | 최소 신장 트리                     |
| 시간복잡도   | $O(E * logV)$                         | $O(E * logV)$                |
| 탐색 방법   | 임의 정점에서 최소 인접 가중치를 가지는 정점을 찾아 확장하는 방식 | 최소 가중치를 가지는 간선부터 하나씩 추가하는 방식 |

# 배낭 문제

- 배낭에 담을 수 있는 최대 무게가 존재하고, 무게와 가치가 다른 짐들이 있습니다.
- 이 짐들을 조합해서 배낭의 무게를 초과하지 않으면서 담은 가치를 최대로 하는 문제

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/Knapsack.svg/500px-Knapsack.svg.png)

## 짐을 쪼갤 수 있는 부분 배낭 문제

- 구하는 방법: 무게당 가치가 높은 짐을 최대한 많이 넣는다.
  1. 짐별로 무게당 가치를 구합니다.
  2. 무게당 가치가 높은 짐부터 넣을 수 있는 만큼 배낭에 넣습니다.
     1. 배낭 용량이 짐 무게보다 크면 짐을 쪼개서 넣습니다.
  3. 과정 2를 배낭이 허용하는 용량이 0이 될 때까지 수행합니다.

## 짐을 쪼갤 수 없는 0/1 배낭 문제

- 해당 문제는 그리디로 풀 수 없고, 동적프로그래밍으로 풀어야 합니다.
- 자세한 풀이: https://howudong.tistory.com/106

|                          | 부분 배낭 문제                  | 0/1 배낭 문제                 |
|--------------------------|---------------------------|---------------------------|
| 알고리즘 목적                  | 배낭 속 짐들의 가치의 합이 최대가 되도록 함 | 배낭 속 짐들의 가치의 합이 최대가 되도록 함 |
| 문제 특징                    | 짐을 쪼갤 수 있음                | 짐을 쪼갤 수 없음                |
| 시간 복잡도 (짐의 갯수: N, 가치: W) | $O(N log N)$              | $O(N * W)$                |
| 그리디 적용 가능 여부             | O                         | X                         |

# 참고자료
- https://velog.io/@elon/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%ACMST-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-Kruskals-Prims
- https://ko.wikipedia.org/wiki/%EB%B0%B0%EB%82%AD_%EB%AC%B8%EC%A0%9C